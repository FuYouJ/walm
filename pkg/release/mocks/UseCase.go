// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	common "WarpCloud/walm/pkg/models/common"
	k8s "WarpCloud/walm/pkg/models/k8s"

	mock "github.com/stretchr/testify/mock"

	release "WarpCloud/walm/pkg/models/release"
)

// UseCase is an autogenerated mock type for the UseCase type
type UseCase struct {
	mock.Mock
}

// ComputeResourcesByDryRunRelease provides a mock function with given fields: namespace, releaseRequest, chartFiles
func (_m *UseCase) ComputeResourcesByDryRunRelease(namespace string, releaseRequest *release.ReleaseRequestV2, chartFiles []*common.BufferedFile) (*release.ReleaseResources, error) {
	ret := _m.Called(namespace, releaseRequest, chartFiles)

	var r0 *release.ReleaseResources
	if rf, ok := ret.Get(0).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) *release.ReleaseResources); ok {
		r0 = rf(namespace, releaseRequest, chartFiles)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*release.ReleaseResources)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) error); ok {
		r1 = rf(namespace, releaseRequest, chartFiles)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ComputeResourcesByGetRelease provides a mock function with given fields: namespace, name
func (_m *UseCase) ComputeResourcesByGetRelease(namespace string, name string) (*release.ReleaseResources, error) {
	ret := _m.Called(namespace, name)

	var r0 *release.ReleaseResources
	if rf, ok := ret.Get(0).(func(string, string) *release.ReleaseResources); ok {
		r0 = rf(namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*release.ReleaseResources)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRelease provides a mock function with given fields: namespace, releaseName, deletePvcs, async, timeoutSec
func (_m *UseCase) DeleteRelease(namespace string, releaseName string, deletePvcs bool, async bool, timeoutSec int64) error {
	ret := _m.Called(namespace, releaseName, deletePvcs, async, timeoutSec)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, bool, int64) error); ok {
		r0 = rf(namespace, releaseName, deletePvcs, async, timeoutSec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteReleaseWithRetry provides a mock function with given fields: namespace, releaseName, deletePvcs, async, timeoutSec
func (_m *UseCase) DeleteReleaseWithRetry(namespace string, releaseName string, deletePvcs bool, async bool, timeoutSec int64) error {
	ret := _m.Called(namespace, releaseName, deletePvcs, async, timeoutSec)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, bool, int64) error); ok {
		r0 = rf(namespace, releaseName, deletePvcs, async, timeoutSec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DryRunRelease provides a mock function with given fields: namespace, releaseRequest, chartFiles
func (_m *UseCase) DryRunRelease(namespace string, releaseRequest *release.ReleaseRequestV2, chartFiles []*common.BufferedFile) ([]map[string]interface{}, error) {
	ret := _m.Called(namespace, releaseRequest, chartFiles)

	var r0 []map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) []map[string]interface{}); ok {
		r0 = rf(namespace, releaseRequest, chartFiles)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) error); ok {
		r1 = rf(namespace, releaseRequest, chartFiles)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DryRunUpdateRelease provides a mock function with given fields: namespace, releaseRequest, chartFiles
func (_m *UseCase) DryRunUpdateRelease(namespace string, releaseRequest *release.ReleaseRequestV2, chartFiles []*common.BufferedFile) (*release.ReleaseDryRunUpdateInfo, error) {
	ret := _m.Called(namespace, releaseRequest, chartFiles)

	var r0 *release.ReleaseDryRunUpdateInfo
	if rf, ok := ret.Get(0).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) *release.ReleaseDryRunUpdateInfo); ok {
		r0 = rf(namespace, releaseRequest, chartFiles)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*release.ReleaseDryRunUpdateInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) error); ok {
		r1 = rf(namespace, releaseRequest, chartFiles)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBackUpRelease provides a mock function with given fields: namespace, name
func (_m *UseCase) GetBackUpRelease(namespace string, name string) (*release.ReleaseInfoV2, error) {
	ret := _m.Called(namespace, name)

	var r0 *release.ReleaseInfoV2
	if rf, ok := ret.Get(0).(func(string, string) *release.ReleaseInfoV2); ok {
		r0 = rf(namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*release.ReleaseInfoV2)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRelease provides a mock function with given fields: namespace, name
func (_m *UseCase) GetRelease(namespace string, name string) (*release.ReleaseInfoV2, error) {
	ret := _m.Called(namespace, name)

	var r0 *release.ReleaseInfoV2
	if rf, ok := ret.Get(0).(func(string, string) *release.ReleaseInfoV2); ok {
		r0 = rf(namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*release.ReleaseInfoV2)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetReleaseEvents provides a mock function with given fields: namespace, name
func (_m *UseCase) GetReleaseEvents(namespace string, name string) (*k8s.EventList, error) {
	ret := _m.Called(namespace, name)

	var r0 *k8s.EventList
	if rf, ok := ret.Get(0).(func(string, string) *k8s.EventList); ok {
		r0 = rf(namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*k8s.EventList)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstallUpgradeRelease provides a mock function with given fields: namespace, releaseRequest, chartFiles, async, timeoutSec, fullUpdate, updateConfigMap
func (_m *UseCase) InstallUpgradeRelease(namespace string, releaseRequest *release.ReleaseRequestV2, chartFiles []*common.BufferedFile, async bool, timeoutSec int64, fullUpdate bool, updateConfigMap bool) error {
	ret := _m.Called(namespace, releaseRequest, chartFiles, async, timeoutSec, fullUpdate, updateConfigMap)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile, bool, int64, bool, bool) error); ok {
		r0 = rf(namespace, releaseRequest, chartFiles, async, timeoutSec, fullUpdate, updateConfigMap)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InstallUpgradeReleaseWithRetry provides a mock function with given fields: namespace, releaseRequest, chartFiles, async, updateConfigMap, timeoutSec
func (_m *UseCase) InstallUpgradeReleaseWithRetry(namespace string, releaseRequest *release.ReleaseRequestV2, chartFiles []*common.BufferedFile, async bool, updateConfigMap bool, timeoutSec int64) error {
	ret := _m.Called(namespace, releaseRequest, chartFiles, async, updateConfigMap, timeoutSec)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile, bool, bool, int64) error); ok {
		r0 = rf(namespace, releaseRequest, chartFiles, async, updateConfigMap, timeoutSec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListBackUpReleases provides a mock function with given fields: namespace
func (_m *UseCase) ListBackUpReleases(namespace string) ([]*release.ReleaseInfoV2, error) {
	ret := _m.Called(namespace)

	var r0 []*release.ReleaseInfoV2
	if rf, ok := ret.Get(0).(func(string) []*release.ReleaseInfoV2); ok {
		r0 = rf(namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*release.ReleaseInfoV2)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReleases provides a mock function with given fields: namespace, filter
func (_m *UseCase) ListReleases(namespace string, filter string) ([]*release.ReleaseInfoV2, error) {
	ret := _m.Called(namespace, filter)

	var r0 []*release.ReleaseInfoV2
	if rf, ok := ret.Get(0).(func(string, string) []*release.ReleaseInfoV2); ok {
		r0 = rf(namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*release.ReleaseInfoV2)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(namespace, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReleasesByLabels provides a mock function with given fields: namespace, labelSelectorStr
func (_m *UseCase) ListReleasesByLabels(namespace string, labelSelectorStr string) ([]*release.ReleaseInfoV2, error) {
	ret := _m.Called(namespace, labelSelectorStr)

	var r0 []*release.ReleaseInfoV2
	if rf, ok := ret.Get(0).(func(string, string) []*release.ReleaseInfoV2); ok {
		r0 = rf(namespace, labelSelectorStr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*release.ReleaseInfoV2)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(namespace, labelSelectorStr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PauseOrRecoverRelease provides a mock function with given fields: namespace, releaseName, async, timeoutSec, paused
func (_m *UseCase) PauseOrRecoverRelease(namespace string, releaseName string, async bool, timeoutSec int64, paused bool) error {
	ret := _m.Called(namespace, releaseName, async, timeoutSec, paused)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, int64, bool) error); ok {
		r0 = rf(namespace, releaseName, async, timeoutSec, paused)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PauseReleaseWithoutChart provides a mock function with given fields: namespace, name
func (_m *UseCase) PauseReleaseWithoutChart(namespace string, name string) error {
	ret := _m.Called(namespace, name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(namespace, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RecoverReleaseWithoutChart provides a mock function with given fields: namespace, name
func (_m *UseCase) RecoverReleaseWithoutChart(namespace string, name string) error {
	ret := _m.Called(namespace, name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(namespace, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReloadRelease provides a mock function with given fields: namespace, name
func (_m *UseCase) ReloadRelease(namespace string, name string) error {
	ret := _m.Called(namespace, name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(namespace, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestartRelease provides a mock function with given fields: namespace, releaseName
func (_m *UseCase) RestartRelease(namespace string, releaseName string) error {
	ret := _m.Called(namespace, releaseName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(namespace, releaseName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestartReleaseIsomate provides a mock function with given fields: namespace, releaseName, isomateName
func (_m *UseCase) RestartReleaseIsomate(namespace string, releaseName string, isomateName string) error {
	ret := _m.Called(namespace, releaseName, isomateName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(namespace, releaseName, isomateName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateReleaseConfigMap provides a mock function with given fields: namespace, name, configMapName, requestBody
func (_m *UseCase) UpdateReleaseConfigMap(namespace string, name string, configMapName string, requestBody *k8s.ConfigMapRequestBody) error {
	ret := _m.Called(namespace, name, configMapName, requestBody)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, *k8s.ConfigMapRequestBody) error); ok {
		r0 = rf(namespace, name, configMapName, requestBody)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateReleaseIngress provides a mock function with given fields: namespace, name, ingressName, requestBody
func (_m *UseCase) UpdateReleaseIngress(namespace string, name string, ingressName string, requestBody *k8s.IngressRequestBody) error {
	ret := _m.Called(namespace, name, ingressName, requestBody)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, *k8s.IngressRequestBody) error); ok {
		r0 = rf(namespace, name, ingressName, requestBody)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
