// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	"WarpCloud/walm/pkg/models/common"
	"WarpCloud/walm/pkg/models/k8s"
	"WarpCloud/walm/pkg/models/release"
	"github.com/stretchr/testify/mock"
)

// UseCase is an autogenerated mock type for the UseCase type
type UseCase struct {
	mock.Mock
}

// ComputeResourcesByDryRunRelease provides a mock function with given fields: namespace, releaseRequest, chartFiles
func (_m *UseCase) ComputeResourcesByDryRunRelease(namespace string, releaseRequest *release.ReleaseRequestV2, chartFiles []*common.BufferedFile) (*release.ReleaseResources, error) {
	ret := _m.Called(namespace, releaseRequest, chartFiles)

	var r0 *release.ReleaseResources
	if rf, ok := ret.Get(0).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) *release.ReleaseResources); ok {
		r0 = rf(namespace, releaseRequest, chartFiles)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*release.ReleaseResources)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) error); ok {
		r1 = rf(namespace, releaseRequest, chartFiles)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteRelease provides a mock function with given fields: namespace, releaseName, deletePvcs, async, timeoutSec
func (_m *UseCase) DeleteRelease(namespace string, releaseName string, deletePvcs bool, async bool, timeoutSec int64) error {
	ret := _m.Called(namespace, releaseName, deletePvcs, async, timeoutSec)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, bool, int64) error); ok {
		r0 = rf(namespace, releaseName, deletePvcs, async, timeoutSec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteReleaseWithRetry provides a mock function with given fields: namespace, releaseName, deletePvcs, async, timeoutSec
func (_m *UseCase) DeleteReleaseWithRetry(namespace string, releaseName string, deletePvcs bool, async bool, timeoutSec int64) error {
	ret := _m.Called(namespace, releaseName, deletePvcs, async, timeoutSec)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, bool, int64) error); ok {
		r0 = rf(namespace, releaseName, deletePvcs, async, timeoutSec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DryRunRelease provides a mock function with given fields: namespace, releaseRequest, chartFiles
func (_m *UseCase) DryRunRelease(namespace string, releaseRequest *release.ReleaseRequestV2, chartFiles []*common.BufferedFile) ([]map[string]interface{}, error) {
	ret := _m.Called(namespace, releaseRequest, chartFiles)

	var r0 []map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) []map[string]interface{}); ok {
		r0 = rf(namespace, releaseRequest, chartFiles)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile) error); ok {
		r1 = rf(namespace, releaseRequest, chartFiles)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRelease provides a mock function with given fields: namespace, name
func (_m *UseCase) GetRelease(namespace string, name string) (*release.ReleaseInfoV2, error) {
	ret := _m.Called(namespace, name)

	var r0 *release.ReleaseInfoV2
	if rf, ok := ret.Get(0).(func(string, string) *release.ReleaseInfoV2); ok {
		r0 = rf(namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*release.ReleaseInfoV2)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstallUpgradeRelease provides a mock function with given fields: namespace, releaseRequest, chartFiles, async, timeoutSec, paused
func (_m *UseCase) InstallUpgradeRelease(namespace string, releaseRequest *release.ReleaseRequestV2, chartFiles []*common.BufferedFile, async bool, timeoutSec int64, paused *bool) error {
	ret := _m.Called(namespace, releaseRequest, chartFiles, async, timeoutSec, paused)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile, bool, int64, *bool) error); ok {
		r0 = rf(namespace, releaseRequest, chartFiles, async, timeoutSec, paused)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InstallUpgradeReleaseWithRetry provides a mock function with given fields: namespace, releaseRequest, chartFiles, async, timeoutSec, paused
func (_m *UseCase) InstallUpgradeReleaseWithRetry(namespace string, releaseRequest *release.ReleaseRequestV2, chartFiles []*common.BufferedFile, async bool, timeoutSec int64, paused *bool) error {
	ret := _m.Called(namespace, releaseRequest, chartFiles, async, timeoutSec, paused)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *release.ReleaseRequestV2, []*common.BufferedFile, bool, int64, *bool) error); ok {
		r0 = rf(namespace, releaseRequest, chartFiles, async, timeoutSec, paused)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ListReleases provides a mock function with given fields: namespace
func (_m *UseCase) ListReleases(namespace string) ([]*release.ReleaseInfoV2, error) {
	ret := _m.Called(namespace)

	var r0 []*release.ReleaseInfoV2
	if rf, ok := ret.Get(0).(func(string) []*release.ReleaseInfoV2); ok {
		r0 = rf(namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*release.ReleaseInfoV2)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListReleasesByLabels provides a mock function with given fields: namespace, labelSelectorStr
func (_m *UseCase) ListReleasesByLabels(namespace string, labelSelectorStr string) ([]*release.ReleaseInfoV2, error) {
	ret := _m.Called(namespace, labelSelectorStr)

	var r0 []*release.ReleaseInfoV2
	if rf, ok := ret.Get(0).(func(string, string) []*release.ReleaseInfoV2); ok {
		r0 = rf(namespace, labelSelectorStr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*release.ReleaseInfoV2)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(namespace, labelSelectorStr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PauseRelease provides a mock function with given fields: namespace, releaseName, async, timeoutSec
func (_m *UseCase) PauseRelease(namespace string, releaseName string, async bool, timeoutSec int64) error {
	ret := _m.Called(namespace, releaseName, async, timeoutSec)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, int64) error); ok {
		r0 = rf(namespace, releaseName, async, timeoutSec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RecoverRelease provides a mock function with given fields: namespace, releaseName, async, timeoutSec
func (_m *UseCase) RecoverRelease(namespace string, releaseName string, async bool, timeoutSec int64) error {
	ret := _m.Called(namespace, releaseName, async, timeoutSec)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, int64) error); ok {
		r0 = rf(namespace, releaseName, async, timeoutSec)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ReloadRelease provides a mock function with given fields: namespace, name
func (_m *UseCase) ReloadRelease(namespace string, name string) error {
	ret := _m.Called(namespace, name)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(namespace, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RestartRelease provides a mock function with given fields: namespace, releaseName
func (_m *UseCase) RestartRelease(namespace string, releaseName string) error {
	ret := _m.Called(namespace, releaseName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(namespace, releaseName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateReleaseIngress provides a mock function with given fields: namespace, name, configMapName, requestBody
func (_m *UseCase) UpdateReleaseIngress(namespace, name, ingressName string, requestBody *k8s.IngressRequestBody) error {
	ret := _m.Called(namespace, name, ingressName, requestBody)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, *k8s.IngressRequestBody) error); ok {
		r0 = rf(namespace, name, ingressName, requestBody)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateReleaseConfigMap provides a mock function with given fields: namespace, name, configMapName, requestBody
func (_m *UseCase) UpdateReleaseConfigMap(namespace, name, configMapName string, requestBody *k8s.ConfigMapRequestBody) error {
	ret := _m.Called(namespace, name, configMapName, requestBody)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string, *k8s.ConfigMapRequestBody) error); ok {
		r0 = rf(namespace, name, configMapName, requestBody)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
